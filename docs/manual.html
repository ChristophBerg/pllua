<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 //EN"
		"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<!-- PL/Lua home -->
<!-- $Id: manual.html,v 1.1 2008/01/04 15:44:04 carvalho Exp $ -->

<head>
	<title>PL/Lua documentation</title>
	<meta name="description" content="PL/Lua" />
	<meta name="keywords" content="postgresql,lua,procedural language" />
	<meta name="author" content="Luis Carvalho" />
	<meta http-equiv="content-language" content="en" />
	<meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8" />
	<meta http-equiv="content-style-type" content="text/css" />
	<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>

<body>
<div id="page">
	
<div id="header">
	<h1>PL/Lua</h1>
  Procedural Lua for PostgreSQL
</div>

<div id="horizbar">
	<a href="#introduction" accesskey="1">Introduction</a>&nbsp; :: &nbsp;
	<a href="#languages">Languages</a>&nbsp; :: &nbsp; 
	<a href="#functions">Functions</a>&nbsp; :: &nbsp; 
	<a href="#database">Database Access</a>&nbsp; :: &nbsp; 
	<a href="#triggers">Triggers</a>&nbsp; :: &nbsp; 
	<a href="#installation">Installation</a>
</div>

<div class="content">

<h2 id="introduction">Introduction</h2>
<small>What PL/Lua is</small>
<p><strong>PL/Lua</strong> is an implementation of
<a href="http://www.lua.org">Lua</a> as a loadable procedural language for
<a href="http://www.postgresql.org">PostgreSQL</a>: with PL/Lua you can use
PostgreSQL functions and triggers written in the Lua programming language.</p>

<p>Procedural languages offer many extra capabilities to PostgreSQL, similar
to C language extensions: control structures, more complex computations than
allowed by SQL, access to user-defined types and database functions and
operators, and restriction to trusted execution.</p>

<p>PL/Lua brings the power and simplicity of Lua to PostgreSQL, including:
small memory footprint, simple syntax, lexical scoping, functions as
first-class values, and coroutines for non-preemptive threading. As a simple
example, consider the following hello function:</p>

<pre>
# CREATE FUNCTION hello(name text) RETURNS text AS $$
  return string.format("Hello, %s!", name) 
$$ LANGUAGE pllua;
CREATE FUNCTION
# SELECT hello('PostgreSQL');
       hello        
--------------------
 Hello, PostgreSQL!
(1 row)
</pre>

<p>The next sections present more examples where other features are used. In
the <a href="#languages">Languages</a> section the two flavors of PL/Lua are
described; the <a href="#functions">Functions</a> section details how
functions are registered in PL/Lua and how arguments are treated;
<a href="#database">Database access</a> presents the
<acronym title="Server Programming Interface">SPI</acronym> interface
to PL/Lua; and <a href="triggers">Triggers</a> shows how triggers can be
declared.</p>

<p>PL/Lua is licensed under the
<a href="http://www.lua.org/license.html">same license as Lua</a> -- the
<a href="http://www.opensource.org/licenses/mit-license.php">MIT license</a>
-- and so can be freely used for academic and commercial purposes. Please
refer to the <a href="#installation">Installation</a> section for more
details.</p>


<h2 id="languages">Languages</h2>
<small>Trusted and Untrusted PL/Lua</small>
<p>PL/Lua is available as either a <em>trusted</em> (<code>pllua</code>) or an
<em>untrusted</em> (<code>plluau</code>) language. In <code>plluau</code> the
user has access to a full-blown Lua environment, similar to the regular
interpreter: all libraries are loaded, the user can access the global table
freely, and modules can be loaded. Only database superusers are allowed to
create functions using this untrusted version of PL/Lua.</p>

<p>Unprivileged users can only create functions using the trusted version of
PL/Lua, <code>pllua</code>. The environment in <code>pllua</code> is more
restricted: only <code>table</code>, <code>string</code>, and
<code>math</code> libraries are fully loaded, the </code>os</code> library is
restricted, the <code>package</code> library is not available, that is, there
is no module system (including <code>require</code>), and the global table is
restricted for writing. The following table summarizes the differences:</p>

<table><tbody>
    <tr>
      <td><strong>Table</strong></td>
      <td><strong><code>plluau</code></strong></td>
      <td><strong><code>pllua</code></strong></td>
    </tr>
    <tr>
      <td><code>table, string, math</code></td>
      <td>All functions</td>
      <td>All functions</td>
    </tr>
    <tr>
      <td><code>os</code></td>
      <td>All functions</td>
      <td><code>date, clock, time, difftime</code></td>
    </tr>
    <tr>
      <td><code>package</code> (module system)</td>
      <td>All functions</td>
      <td>None</td>
    </tr>
    <tr>
      <td><code>_G</code> (global environment)</td>
      <td>Free access</td>
      <td>Writing is restricted</td>
    </tr>
</tbody></table>

<p>Even though the module system is absent in <code>pllua</code>, PL/Lua
allows for modules to be automatically loaded after creating the environment:
all entries in table <code><em>pllua.init</em></code> are
<code>require</code>'d at startup.</p>

<p>To facilitate the use of PL/Lua and following the tradition of other PLs,
the global table is aliased to <code>shared</code>. Moreover, write access to
the global table in <code>pllua</code> is restricted to avoid pollution;
global variables should then be created with
<a href="#setshared"><code>setshared</code></a>.</p>

<p>Finally, errors in PL/Lua are propagated to the calling query and the
transaction is aborted if the error is not caught. Messages can be emitted by
<code>log</code>, <code>info</code>, <code>notice</code>, and
<code>warning</code> at log levels LOG, INFO, NOTICE, and WARNING
respectively. In particular, <code>print</code> emits a log message of level
INFO and is equivalent to <code>info</code>.</p>

<h4 id="setshared"><code>setshared(varname [, value])</code></h4>
<p>Sets global <code>varname</code> to <code>value</code>, which defaults to
<code>true</code>. It is semantically equivalent to
<code>shared[varname] = value</code>.</p>


<h2 id="functions">Functions</h2>
<small>Functions and data values in PL/Lua</small>
<p>PL/Lua functions are created according to the following prototype:

<pre>
CREATE FUNCTION <strong>func</strong>(<em>args</em>) RETURNS <em>rettype</em> AS $$
  <em>-- Lua function body</em>
$$ LANGUAGE [pllua | plluau];
</pre>

where <code>args</code> should be <em>named</em> arguments.
There is no conversion of arguments to string/text form between Lua and
PostgreSQL. Basic data types -- like integer, double, text -- and their arrays
are supported. The value returned by <code>func</code> is converted to a datum
of type <code>rettype</code> unless <code>rettype</code> is <code>void</code>.</p>

<p>The function body is composed as below to become a typical Lua chunk:</p>

<pre>
local <em>upvalue</em>, <strong>func</strong>
<strong>func</strong> = function(<em>argnames</em>)
  <em>-- Lua function body</em>
end
return <strong>func</strong>
</pre>

<p>The resulting chunk is then compiled and stored in the registry of the PL/Lua
state as a function with the same name. It is important to have the above
structure in mind when writing PL/Lua functions. As an example, consider the
following function:</p>

<pre>
CREATE FUNCTION max(a integer, b integer) RETURNS integer AS $$
  if a == nil then return b end <em>-- first arg is NULL?</em>
  if b == nil then return a end <em>-- second arg is NULL?</em>
  return a &gt; b and a or b <em>-- return max(a, b)</em>
$$ LANGUAGE pllua;
</pre>

<p>Note that <code>max</code> is not strict and returns <code>NULL</code> when
both <code>a</code> and <code>b</code> are <code>NULL</code>.</p>

<p>Since functions in PL/Lua are stored with their declared names, they can be
recursive:</p>

<pre>
CREATE FUNCTION fib(n int) RETURNS int as $$
  if n &lt; 3 then
    return n
  else
    return fib(n - 1) + fib(n - 2)
  end
$$ LANGUAGE pllua;
</pre>

<p>Moreover, as can be seen in the composition of <code>func</code> above,
PL/Lua functions are actually <em>closures</em> on
<code><em>upvalue</em></code>. The user can think of <code>upvalue</code> as
local cache to <code>func</code> that could -- and should! -- be used instead
of the global state to store values. Quick example:</p> 

<pre>
CREATE FUNCTION counter() RETURNS int AS $$
  while true do
    upvalue = upvalue + 1
    coroutine.yield(upvalue)
  end
end
do
  upvalue = 0 <em>-- counter</em>
  counter = coroutine.wrap(counter)
$$ LANGUAGE pllua;
</pre>

<p>Function <code>counter</code> is similar to an iterator, returning
consecutive integers everytime it is called, starting at one. Note that we
need to add <code>end</code> to finish the function definition body and
<code>do</code> to start a new block since the process of function composition
always appends an <code>end</code>. It is important to observe that what
actually gets defined as <code>counter</code> is a wrapper around a
coroutine.</p>

<p>Arrays are converted to Lua tables with integer indices, while composite
types become tables with keys corresponding to attribute names:</p>

<pre>
CREATE TYPE greeting AS (how text, who text);

CREATE FUNCTION makegreeting (g greeting, f text) RETURNS text AS $$
  return string.format(f, g.how, g.who)
$$ LANGUAGE pllua;
</pre>

<p>Set-returning functions (SRFs) are implemented in PL/Lua using coroutines.
When a SRF <code>func</code> is first called a new Lua thread is created
and <code>func</code> is pushed along with its arguments onto the new thread's
stack. A new result is then returned whenever <code>func</code> yields and
<code>func</code> is done when the coroutine suspends or finishes. Using our
composite type from above, we can define

<pre>
CREATE FUNCTION greetingset (how text, who text[])
    RETURNS SETOF greeting AS $$
  for _, name in ipairs(who) do
    coroutine.yield{how=how, who=name}
  end
$$ LANGUAGE pllua;
</pre>

with this usage example:

<pre>
# SELECT makegreeting(greetingset, '%s, %s!') FROM
  (SELECT greetingset('Hello', ARRAY['foo', 'bar', 'psql'])) AS q;
 makegreeting 
--------------
 Hello, foo!
 Hello, bar!
 Hello, psql!
(3 rows)
</pre>
</p>

<p>Now, to further illustrate the use of arrays in PL/Lua, we adapt an
<a href="http://www.lua.org/pil/9.3.html">example</a>
from <a href="http://www.lua.org/pil"><em>Programming in Lua</em></a>:</p>

<pre>
CREATE FUNCTION perm (a text[]) RETURNS SETOF text[] AS $$
  upvalue(a, #a)
end
do
  upvalue = function (a, n) <em>-- permgen in PiL</em>
    if n == 0 then
      coroutine.yield(a) <em>-- return next SRF row</em>
    else
      for i = 1, n do
        a[n], a[i] = a[i], a[n] <em>-- i-th element as last one</em>
        upvalue(a, n - 1) <em>-- recurse on head</em>
        a[n], a[i] = a[i], a[n] <em>-- restore i-th element</em>
      end
    end
  end
$$ LANGUAGE pllua;
</pre>

<p>As stated in <a href="#languages">Languages</a>, it is possible to access
the global table of PL/Lua's state. However, as noted before, since PL/Lua
functions are closures, creating global variables should be restricted to
cases where data is to be shared between different functions. The following
simple example defines a getter-setter pair to access a shared variable
<code>counter</code>:</p>

<pre>
CREATE FUNCTION getcounter() RETURNS integer AS $$
  if shared.counter == nil then <em>-- not cached?</em>
    setshared("counter", 0)
  end
  return counter <em>-- _G.counter == shared.counter</em>
$$ LANGUAGE pllua;

CREATE FUNCTION setcounter(c integer) RETURNS void AS $$
  if shared.counter == nil then <em>-- not cached?</em>
    setshared("counter", c)
  else
    counter = c <em>-- _G.counter == shared.counter</em>
  end
$$ LANGUAGE pllua;
</pre>


<h2 id="database">Database Access</h2>
<small>Server interface in PL/Lua</small>

<p>The server interface in PL/Lua comprises the methods in table
<code>server</code> and userdata <code>plan</code>, <code>cursor</code>,
<code>tuple</code>, and <code>tuptable</code>.</p>

<h3><code>server</code></h3>
<p>The <code>server</code> table contains methods to prepare plans, execute
SQL commands, and find cursors. It is SPI's entry point in PL/Lua.</p>

<h4 id="server_execute">
  <code>server.execute(cmd, readonly [, count])</code>
</h4>
<p>Executes the SQL statement <code>cmd</code> for <code>count</code> rows. If
<code>readonly</code> is <code>true</code>, the command is assumed to be
read-only and execution overhead is reduced. If <code>count</code> is zero
then the command is executed for all rows that it applies to; otherwise at
most <code>count</code> rows are returned. <code>count</code> defaults to
zero. <code>server.execute</code> returns a <em>tuptable</em>.</p>

<h4 id="server_find"><code>server.find(name)</code></h4>
<p>Finds an existing cursor with name <code>name</code> and returns a cursor
userdatum or <code>nil</code> if the cursor cannot be found.</p>

<h4 id="server_prepare"><code>server.prepare(cmd, argtypes)</code></h4>
<p>Prepares and returns a plan from SQL statement <code>cmd</code>. If
<code>cmd</code> specifies input parameters, their types should be specified
in table <code>argtypes</code>. The returned plan should not be used outside
the current invocation of <code>server.prepare</code> since it is freed by
<code>SPI_finish</code>. Use <a href="#plan_save">plan:save</a> if you wish to
store the plan for latter application.</p>

<h3 id="plans">Plans</h3>
<p>TODO: intro to plans.</p>

<h4 id="plan_execute">
  <code>plan:execute(cmd, args, readonly [, count])</code>
</h4>
<p>Executes a previously prepared plan with parameters in table
<code>args</code>. <code>readonly</code> and <code>count</code> have the same
meaning as in <a href="#server_execute">server.execute</a>.</p>

<h4 id="plan_getcursor"><code>plan:getcursor(args, readonly, name)</code></h4>
<p>Sets up a cursor with name <code>name</code> from a prepared plan.
<code>readonly</code> has the same meaning as in
<a href="#server_execute">server.execute</a>.</p>

<h4 id="plan_issaved"><code>plan:issaved()</code></h4>
<p>Returns <code>true</code> if plan is saved and <code>false</code>
otherwise.</p>

<h4 id="plan_save"><code>plan:save()</code></h4>
<p>Saves a prepared plan for subsequent invocations in the current
session.</p>

<h3 id="cursors">Cursors</h3>
<p>Using a cursor instead of executing the plan directly has two benefits. First,
the result rows can be retrieved a few at a time, avoiding memory overrun for
queries that return many rows. Second, a portal can outlive the current
procedure (it can, in fact, live to the end of the current transaction).</p>

<h4 id="cursor_fetch"><code>cursor:fetch([count])</code></h4>
<p>Fetches at most <code>count</code> rows from a cursor. If
<code>count</code> is <code>nil</code> or zero then all rows are fetched. If
<code>count</code> is negative the fetching runs backward.</p>

<h4 id="cursor_move"><code>cursor:move([count])</code></h4>
<p>Skips <code>count</code> rows in a cursor, where <code>count</code>
defaults to zero. If <code>count</code> is negative the moving runs
backward.</p>

<h4 id="cursor_close"><code>cursor:close()</code></h4>
<p>Closes a cursor.</p>


<h3>Examples</h3>

<pre>
CREATE TABLE tree (id INT PRIMARY KEY, lchild INT, rchild INT);
</pre>

<pre>
CREATE FUNCTION filltree (t text, n int) RETURNS void AS $$
  local p = server.prepare("insert into " .. t .. " values($1, $2, $3)",
    {"int4", "int4", "int4"})
  for i = 1, n do
    local lchild, rchild = 2 * i, 2 * i + 1 <em>-- siblings</em>
    p:execute{i, lchild, rchild}
  end
$$ LANGUAGE pllua;
</pre>

<pre>
CREATE FUNCTION preorder (t text, s int) RETURNS SETOF int AS $$
  coroutine.yield(s)
  local q = server.execute("select * from " .. t .. " where id=" .. s,
      true, 1)
  if q ~= nil then
    local lchild, rchild = q[1].lchild, q[1].rchild <em>-- store before next query</em>
    if lchild ~= nil then preorder(t, lchild) end
    if rchild ~= nil then preorder(t, rchild) end
  end
$$ LANGUAGE pllua;
</pre>

<pre>
CREATE FUNCTION postorder (t text, s int) RETURNS SETOF int AS $$
  local p = upvalue[t]
  if p == nil then <em>-- not cached?</em>
    p = server.prepare("select * from " .. t .. " where id=$1", {"int4"})
    upvalue[t] = p:save()
  end
  local q = p:execute({s}, true, 1) <em>-- read-only, one row</em>
  if q ~= nil then
    local lchild, rchild = q[1].lchild, q[1].rchild <em>-- store before next query</em>
    if lchild ~= nil then postorder(t, lchild) end
    if rchild ~= nil then postorder(t, rchild) end
  end
  coroutine.yield(s)
end
do upvalue = {}
$$ LANGUAGE pllua;
</pre>


<h2 id="triggers">Triggers</h2>
<small>Triggers in PL/Lua</small>

<h3>Example</h3>

<pre>
create function treetrigger() returns trigger as $$
  local row, operation = trigger.row, trigger.operation
  if operation == "update" then
    trigger.row = nil <em>-- updates not allowed</em>
  elseif operation == "insert" then
    local id, lchild, rchild = row.id, row.lchild, row.rchild
    if lchild == rchild or id == lchild or id == rchild <em>-- avoid loops</em>
        or (lchild ~= nil and upvalue.intree(lchild)) <em>-- avoid cycles</em>
        or (rchild ~= nil and upvalue.intree(rchild))
        or (upvalue.nonemptytree() and not upvalue.isleaf(id)) <em>-- not leaf?</em>
        then
      trigger.row = nil
    end
  else <em>-- operation == "delete"</em>
    if not upvalue.isleafparent(row.id) then <em>-- not both leaf parent?</em>
      trigger.row = nil
    end
  end
end
do
  local getter = function(cmd, ...)
    local plan = server.prepare(cmd, {...}):save()
    return function(...)
      return plan:execute({...}, true) ~= nil
    end
  end
  upvalue = { <em>-- plan closures</em>
    nonemptytree = getter("select * from tree"),
    intree = getter("select node from (select id as node from tree "
      .. "union select lchild from tree union select rchild from tree) as q "
      .. "where node=$1", "int4"),
    isleaf = getter("select leaf from (select lchild as leaf from tree "
      .. "union select rchild from tree except select id from tree) as q "
      .. "where leaf=$1", "int4"),
    isleafparent = getter("select lp from (select id as lp from tree "
      .. "except select ti.id from tree ti join tree tl on ti.lchild=tl.id "
      .. "join tree tr on ti.rchild=tr.id) as q where lp=$1", "int4")
  }
$$ language pllua;
</pre>

<pre>
create trigger tree_trigger before insert or update or delete on tree
  for each row execute procedure treetrigger();
</pre>


<h2 id="installation">Installation</h2>
<small>How to obtain and install PL/Lua</small>
<p>PL/Lua is distributed as a source package or in binary format, and can be
installed as a regular PostgreSQL module:</p>

<pre>
$ psql -f pllua.sql <em>&lt;database&gt;</em>
</pre>

<p>The SQL script <code>pllua.sql</code> installs both trusted and untrusted
flavors of PL/Lua and creates the module table <code>pllua.init</code>.</p>


</div><!-- end content -->

<div id="footer">
<p>
<a href="http://validator.w3.org/check/referer">Valid XHTML 1.1</a>
&nbsp; :: &nbsp;
<a href="http://jigsaw.w3.org/css-validator/check/referer">Valid CSS</a>
<br />
Last modified: $Date: 2008/01/04 15:44:04 $, $Author: carvalho $.
</p>
</div>

</div><!-- end page -->
</body>
</html>

<!-- vi:set sw=2 ts=2 noai: -->
